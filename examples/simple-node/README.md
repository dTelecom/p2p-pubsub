# Simple Node Example

This example demonstrates how to create a simple P2P node using the pubsub library with an interactive CLI.

## Quick Start

1. **Generate keypairs and test configuration:**
   ```bash
   ./test-demo.sh
   ```

2. **Run the demo manually:**
   ```bash
   # Terminal 1 - Start first node (bootstrap)
   go run main.go -config=node1_config.json

   # Terminal 2 - Start second node
   go run main.go -config=node2_config.json
   ```

## Features

- üìã **Interactive CLI** for subscribe/publish/unsubscribe operations  
- üîî **Real-time message notifications** with pretty printing
- üë• **Peer management** and status monitoring
- üîê **Mock authorization** that demonstrates registry integration
- üì° **Bootstrap discovery** for automatic peer finding

## CLI Commands

- `subscribe <topic>` - Subscribe to a topic
- `publish <topic> <message>` - Publish a message to a topic  
- `unsubscribe <topic>` - Unsubscribe from a topic
- `peers` - Show connected peers
- `status` - Show node status
- `help` - Show help message
- `quit` - Exit the node

## Example Usage

```bash
> subscribe sensors
‚úÖ Subscribed to topic: sensors

> publish sensors {"temperature": 25.5, "humidity": 60}
üì§ Published message to topic 'sensors' (ID: abc123...)

> status
üìä Node Status:
  Node ID: simple-node-1
  Peer ID: 12D3KooW...
  Connected Peers: 1
  Subscribed Topics: [sensors]
```

## Using with LiveKit Logger

If you're integrating with LiveKit applications, you can use the LiveKit logger adapter:

```go
package main

import (
    "context"
    "github.com/dtelecom/p2p-pubsub/common"
    "github.com/dtelecom/p2p-pubsub/pubsub"
    "github.com/livekit/protocol/logger"
)

func main() {
    // Get your LiveKit logger instance
    livekitLogger := logger.GetLogger()
    
    // Create adapter for p2p-pubsub
    pubsubLogger := common.NewLivekitLoggerAdapter(livekitLogger)
    
    // Use in config
    config := common.Config{
        WalletPrivateKey:     "your_base58_encoded_private_key",
        DatabaseName:         "depin-network",
        GetAuthorizedWallets: getAuthorizedWallets,
        GetBootstrapNodes:    getBootstrapNodes,
        Logger:               pubsubLogger, // Use LiveKit logger
        ListenPorts: common.ListenPorts{
            QUIC: 4001,
            TCP:  4002,
        },
    }
    
    // Connect to network
    ctx := context.Background()
    db, err := pubsub.Connect(ctx, config)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Disconnect(ctx)
    
    // Your application logic here...
}
```

## Configuration

The example uses JSON configuration files generated by `test-demo.sh`:

```json
{
  "node_id": "simple-node-1",
  "wallet_private_key": "base58_encoded_key",
  "quic_port": 4001,
  "tcp_port": 4002,
  "is_bootstrap": true
}
```

## Mock Registry Functions

The example includes mock implementations of the required registry functions:

- `getAuthorizedWallets()` - Returns a list of authorized Solana public keys
- `getBootstrapNodes()` - Returns a list of bootstrap nodes for discovery

These would be replaced with real smart contract queries in production. 